<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>深入理解计算机系统第五章：优化程序性能 |  Kama</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="engineering-深入理解计算机系统第五章：优化程序性能"
  class="article article-type-engineering"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  深入理解计算机系统第五章：优化程序性能
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" class="article-date">
  <time datetime="2022-11-10T17:18:12.553Z" itemprop="datePublished">2022-11-11</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">29 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="深入理解计算机系统第五章：优化程序性能"><a href="#深入理解计算机系统第五章：优化程序性能" class="headerlink" title="深入理解计算机系统第五章：优化程序性能"></a>深入理解计算机系统第五章：优化程序性能</h1><blockquote>
<p>编写高效程序需要做到一下几步：第一，我们必须选择一组适当的算法和数据结构。第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。</p>
</blockquote>
<h2 id="5-1-优化编译器的能力和局限性"><a href="#5-1-优化编译器的能力和局限性" class="headerlink" title="5.1 优化编译器的能力和局限性"></a>5.1 优化编译器的能力和局限性</h2><p>​		现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及他们是如何使用的。然后会利用一些机会来简化表达式。大多数编译器，包括 GCC，向用户提供了一些对它们所使用的优化的控制。这即最简单的控制方式：<strong>指定优化级别</strong>。在 GCC 中，命令行选项“-Og”调用 GCC 是让 GCC 使用一组最基本的优化。“-O2”、“-O3”调用 GCC 会让它使用更大量的优化，在提高程序性能的同时也可能增加程序的规模。<br>为了保证优化后的程序与优化前有一样的行为，编译器必须很小心地对程序只使用<strong>安全的优化</strong>，因为存在妨碍优化的因素。<br>第一个妨碍优化的因素是可能出现<strong>内存别名使用（memory aliasing）</strong>的情况。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*q = y;</span><br><span class="line">*p = x;</span><br><span class="line">t1 = *q;</span><br></pre></td></tr></table></figure>

<p>*p 和 *q 很明显互不相关，一个1000，一个3000，但如果p 和q 指向的是同一个地址，那么分开赋值将会变成对一个目标二次赋值，最后 t1 的结果当然也就不同了。<br>第二个妨碍优化的因素是函数调用：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f() + f() + f() + f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span> * f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来两段程序能实现同一个功能，但是明显的第一个函数性能会不如第二个函数，因为它对函数 f 调用了四次。但是我们考虑函数 f 的这种情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> counter = <span class="number">0</span>;</span><br><span class="line">=</span><br><span class="line"><span class="type">long</span> f()&#123;</span><br><span class="line">  <span class="keyword">return</span> counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这个函数会修改全局程序状态的一部分，这样的话每一次调用的返回值都会发生变化，就和4 乘上第一次调用它的返回值大相径庭了。<br>​		包含函数调用的代码可以用一个成为<strong>内联函数替换（inline subsitution）</strong>的过程进行，也就是将函数调用替换成函数体。在某些情况下，最好能阻止编译器执行内联替换，如果一个函数已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败，并且用内联替换消除的函数调用是无法被正确剖析的，也就无法正确评估程序性能。</p>
<h2 id="5-2-表示程序性能"><a href="#5-2-表示程序性能" class="headerlink" title="5.2 表示程序性能"></a>5.2 表示程序性能</h2><blockquote>
<p>我们引入度量标准每元素的周期数（Cycles Per Element, CPE）,作为一种表示程序性能并指导我们改进代码的方式。度量值表示的是执行了多少条指令，而不是时钟运行的有多快。<br>  处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹（GHz），即十亿周期每秒钟来表示。 </p>
</blockquote>
<h2 id="5-3-程序示例"><a href="#5-3-程序示例" class="headerlink" title="5.3 程序示例"></a>5.3 程序示例</h2><blockquote>
<p>这里记录一块数据示例，接下来会对这段代码进行不断地优化改进。</p>
</blockquote>
<p>我们首先声明如下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create abstract data type for vector */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> len;</span><br><span class="line">	data</span><br><span class="line">	<span class="type">data_t</span> *data;</span><br><span class="line">&#125;vec_rec, *vec_ptr;</span><br></pre></td></tr></table></figure>

<p>接着给出的是一些生成向量、访问向量元素以及确定向量长度的基本过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create vector of specified length */</span></span><br><span class="line">vec_ptr <span class="title function_">new_vec</span><span class="params">(<span class="type">long</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Allocate header structure */</span></span><br><span class="line">	vec_ptr result = (vec_ptr) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vec_rec));</span><br><span class="line">	<span class="type">data_t</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!result)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* Couldn&#x27;t allocate storage */</span></span><br><span class="line">	result-&gt;len = len;</span><br><span class="line">    <span class="comment">/*Allocate array*/</span></span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        data = (<span class="type">data_t</span> *)<span class="built_in">calloc</span>(len, <span class="keyword">sizeof</span>(<span class="type">data_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!data) &#123;</span><br><span class="line">            <span class="built_in">free</span>((<span class="type">void</span> *) result);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* Couldn&#x27;t allocate storage*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* Data will either be NULL or allocated array */</span></span><br><span class="line">	result-&gt;data = data;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Retrieve vector element and store at dest.</span></span><br><span class="line"><span class="comment"> * Return 0 (out of bounds) or 1 (successful)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_vec_element</span><span class="params">(vecÿptr v, <span class="type">long</span> index, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt;<span class="number">011</span> index &gt;= v-&gt;len)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	*dest = v-&gt;data[index];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return length, of vector */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">vec_length</span><span class="params">(vec_ptr v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是优化示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Implementation with maximum use of data abstraction */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combinel</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> i;</span><br><span class="line">	</span><br><span class="line">	*dest = IDENT;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vec_length(v); i++) &#123;</span><br><span class="line">		<span class="type">data_t</span> val;</span><br><span class="line">		get_vec_element(v, i, &amp;val);</span><br><span class="line">		*dest = *dest OP val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		它计算地是向量元素的乘积。我们使用 IDENT 和 OP 的宏定义来使得这段代码可以重新编译成对数据执行不同的运算。</p>
<h2 id="5-4-消除循环的低效率"><a href="#5-4-消除循环的低效率" class="headerlink" title="5.4 消除循环的低效率"></a>5.4 消除循环的低效率</h2><p>​		循环每一轮都在执行类似的步骤，但其实有些算式不一定要在每个循环中都使用。就比如循环条件是数组长度，但是如果你循环条件写的是<code>I &lt; len()</code> 的话，那程序就会在每一轮循环执行对数据长度的计算函数，这样就降低了程序的性能，如果我们尝试将对数据长度的求值放在循环外面，就可以消除这样的低效率。</p>
<h3 id="优化代码combine2："><a href="#优化代码combine2：" class="headerlink" title="优化代码combine2："></a>优化代码combine2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*Move call to vec_length out of loop */</span><br><span class="line">void combine2(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line">	long length = vec_length(v);</span><br><span class="line">	</span><br><span class="line">	*dest = IDENT;</span><br><span class="line">	for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		data_t val;</span><br><span class="line">		get_vec</span><br><span class="line">		get_vec_element(v, i, &amp;val);</span><br><span class="line">		*dest = *dest OP val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这个优化是一类常见的优化的一个例子，成为代码移动（code motion）。这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p>
<h2 id="5-5-减少过程调用"><a href="#5-5-减少过程调用" class="headerlink" title="5.5 减少过程调用"></a>5.5 减少过程调用</h2><p>​		过程调用会带来开销，并且妨碍大多数形式的程序优化。 所以减少过程调用有可能可以帮助提升程序性能。</p>
<h3 id="优化代码combine3："><a href="#优化代码combine3：" class="headerlink" title="优化代码combine3："></a>优化代码combine3：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">data_t</span> *<span class="title function_">get_vec_start</span><span class="params">(vec.ptr v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> v-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Direct access to vector data */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine3</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">	<span class="type">long</span> i;</span><br><span class="line">	<span class="type">long</span> length = vecÿlength(v);</span><br><span class="line">	<span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line"></span><br><span class="line">	*dest = IDENT;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		*dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		之前的程序每一次循环都会调用<code>get_vec_elemrnt</code>来获取下一个元素，它实际上就是对向量边界检查然后指针赋值。由于我们对程序简单分析即可知道程序中的所有引用都是合法的。所以我们用函数<code>get_vec_start</code>来替换先前的函数，它直接进行指针赋值去省掉了边界检查的步骤。但是我们测试发现程序的性能没有明显的提升，甚至整数求和的性能还略有下降。显然，内循环中的其他操作形成了瓶颈，限制性能超过了边界检查函数，这里的原因在之后我们会提到。</p>
<h2 id="5-6-消除不必要的内存引用"><a href="#5-6-消除不必要的内存引用" class="headerlink" title="5.6 消除不必要的内存引用"></a>5.6 消除不必要的内存引用</h2><p>我们查看<strong>combine3</strong>的内循环部分编译出的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Inner loop of combine3. data_t = double, OP = *</span><br><span class="line">dest in %rbx, data+i in %rdx, data+length in %rax</span><br><span class="line">.L17:									loop:</span><br><span class="line">	vmovsd (%rbx), %xmm0					Read product from dest</span><br><span class="line">	vmulsd (%rdx), %xmm0, %xmm0				Multiply product by data[i]	</span><br><span class="line">	vmovsd %xmm0, (%rbx)					Store product at dest</span><br><span class="line">	addq	$8, %rdx						Increment data+i</span><br><span class="line">	cmpq	%rax, %rdx						Compare to data+length</span><br><span class="line">	jne .L17								If !=, goto loop</span><br></pre></td></tr></table></figure>

<p>​		我们可以看到这个循环每次迭代时，积累的变量都要从内存读出再写入到内存。这样的读写十分浪费，因为每次迭代开始时从 dest 读出的值就是上次迭代最后写入的值。</p>
<h3 id="优化代码combine4："><a href="#优化代码combine4：" class="headerlink" title="优化代码combine4："></a>优化代码combine4：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Accumulate result in local variable */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> i;</span><br><span class="line">	<span class="type">long</span> length = vec_length(v);</span><br><span class="line">	<span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">	<span class="type">data_t</span> acc = IDENT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		acc = OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">	*dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inner loop of combine4. data_t = double, OP = *</span><br><span class="line">acc in %xmm0, data+i in %rdx, data+length in %rax</span><br><span class="line">.L25:								loop:</span><br><span class="line">	vmulsd 	(%rdx), %xmm0, %xmm0		Multiply acc by data[i]</span><br><span class="line">	addq 	$8, %rdx					Increment data+i</span><br><span class="line">	cmpq	%rax, %rdx					Compare to data+length</span><br><span class="line">	jne		.L25						If !=, goto loop</span><br></pre></td></tr></table></figure>

<p>​		combine4 引入一个临时变量 acc，它在循环中用来累积计算出来的值。只有在循环完成的时候结果才存放进 dest 中。与 combine3 中的循环相比，我们将每次迭代的内存操作从两次读和一次写减少到只需要一次读。</p>
<h2 id="5-7-理解现代处理器"><a href="#5-7-理解现代处理器" class="headerlink" title="5.7 理解现代处理器"></a>5.7 理解现代处理器</h2><p>​		前面我们所运用的优化都不依赖于目标机器的任何特性，只是简单地降低了过程调用的开销，以及消除一些给优化编译器造成困难的因素。随着试图进一步提高性能，必须考虑利用<strong>处理器微体系结构</strong>的优化，也就是处理器用来执行指令的底层系统设计。<br>  处理器看似是每次执行一条指令（从寄存器或内存中取值，执行操作，并把结果存回寄存器或者内存），但其实在实际的处理器操作中，是同时对多条指令求值的，这个现象称为<strong>指令级并行</strong>。<br>​		有两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限（latency bound）</strong>,因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。<strong>吞吐量界限（throughput bound）</strong>刻画了处理器功能单元的原始计算能力。这个界限是程序的终极限制。</p>
<p>​		近期的 Intel 处理器在工业界称为<strong>超标量（superscalar）</strong>,意思是它可以在每个时钟周期执行多个操作，而且是<strong>乱序的（out-of-order）</strong>,意思就是指令执行的顺序不一定要与它们在机器级程序中的顺序一致。本章我们的设计并不是严格地基于它，整个设计包括两个主要部分：<strong>指令控制单元（Instruction Control Unit</strong></p>
<p><strong>,ICU）</strong>和<strong>执行单元（Execution Unit,EU）</strong>。前者负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据地基本操作，而后者负责执行这些操作。</p>
<p>​		ICU 从指令高速缓存（instruction cache）中读取指令，指令高速缓存是一个特殊地高速存储器，包含最近访问的指令。当程序遇到分支时，现代处理器采用了一种称为<strong>分支预测（branch prediction）</strong>的技术，处理器会开始取出位于它预测分支的目标地址。使用<strong>投机执行（speculative execution）</strong>的技术，处理器会开始取出位于它预测的分支会跳转到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。<code>标记为取值控制的块包括分支预测，以完成确定取哪些指令的任务。</code></p>
<p>​		<strong>指令译码</strong>逻辑接收实际的程序指令，并将它们转换成一组基本操作（有时称为微操作）。每个这样的指令都完成某个简单的计算任务，例如两数相加、从内存中读取数据，或是向内存中写入数据。具有复杂指令的机器，一条指令可以被译码成多个操作（例如：<code>addq	%rax, 8(%rdx)</code>）</p>
<p>​		EU 接收来自取指单元的操作。通常，每个时钟周期会接受多个操作。这些操作会被分派到一组<u>功能单元</u>中，它们会执行实际的操作。这些功能单元专门用来处理不同类型的操作。</p>
<p>​		读写内存是由加载和存储单元实现的。加载单元处理从内存读取数据到处理器的操作。这个单元有一个加法器来完成地址计算。类似，存储单元处理从处理器写数据到内存的操作也有一个加法器来完成地址计算。加载和存储单元通过<strong>数据高速缓存（data cache）</strong>来访问内存。数据高速缓存是一个高速存储器，存放着最近访问的数据值。</p>
<p>​		使用投机执行技术对操作求值，但最终的结果会知道处理器确定应该实际执行这些操作后，才会将结果存储到程序寄存器和数据内存中。分支操作会被送到 EU，不是确定分支该往哪里去，而是确定分支预测是否正确。</p>
<p>​		在 ICU 中，<strong>退役单元（retirement unit）</strong>记录正在进行的处理，并确保它遵守机器级程序的顺序语义。一旦一条指令执行完毕且分支预测正确，那么退役单元就将其<strong>退役</strong>，若分支预测错误，那么退役单元则会将它<strong>清空</strong>，丢弃所有的计算的结果。任何对程序寄存器的更新都只会在指令退役时才会发生。为了加速一条指令到另一条指令的结果的传送，许多此类的信息是在执行单元间进行交换的。</p>
<p>​		控制操作数在执行单元间传送的最常见的机制称为<strong>寄存器重命名（register renaming）</strong>。简单来说就是对于更新寄存器 a 的指令译码产生一个指向该操作结果的唯一标识符 t 。然后将（a，t）这样的条目加入到一个表中。指令执行产生用 t 标识的 b 结果。然后后续等待 a 作为源的操作都可以使用 b 作为源值。</p>
<p>​		每个运算都是由以下数值来刻画的：一个是<strong>延迟（latebcy）</strong>，它表示完成运算所需要的总时间；另一个时<strong>发射时间（issue time）</strong>,它表示两个连续的同类型的运算之间需要的最小时钟周期数；还有一个是<strong>容量（capacity）</strong>,它表示能够执行该运算的功能单元的数量。</p>
<p>​		对于浮点数和整数的基本操作加法和乘法，他们的发射时间都为1，说明每个时钟周期都可以开始一条这样同类型的运算，这就得益于流水线的作用。流水线功能单元的实现为一系列的阶段，每个阶段完成一部分的运算。发射时间为 1 的功能单元被称为<strong>完全流水线化的</strong>（fully pipelined）：每个时钟周期可以开始一个新的运算，而 {出现容量大于 1 的运算时由于有多个功能单元。</p>
<p>​		除法器并不是完全流水线化的——它的发射时间等于它的延迟，即在开始一条新的运算之前，除法器必须完成整个除法。</p>
<p>​		表达发射时间的一种更常见的方法是指明这个功能单元的<strong>最大吞吐量</strong>，定义为发射时间的倒数。一个完全流水线化的功能单元具有最大的吞吐量；发射时间越大，吞吐量越小；功能单元增加可以进一步提高吞吐量。对一个容量为 <em>C</em>，发射时间为 <em>I</em> 的操作来说，处理器可能获得的吞吐量为每时钟周期 <em>C &#x2F; I</em> 个操作。</p>
<p>​		我们使用<strong>延迟界限</strong>与<strong>吞吐量界限</strong>来描述算术运算的延迟、发射时间和容量对合并函数的影响。延迟界限给出了任何必须按照严格顺序完成合并运算的函数所需要的最小 CPE 值。根据功能单元产生结果的最大速率，吞吐量界限给出了 CPE 的最小界限。</p>
<h2 id="5-8-循环展开"><a href="#5-8-循环展开" class="headerlink" title="5.8 循环展开"></a>5.8 循环展开</h2><p>​		循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p>
<h3 id="优化代码combine5："><a href="#优化代码combine5：" class="headerlink" title="优化代码combine5："></a>优化代码combine5：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 2 x 1 loop unrolling */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">comnbine5</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length<span class="number">-1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        acc = (acc OP data[i]) OP data[i+<span class="number">1</span>];   <span class="comment">/* 一次循环完成两次运算，即 result = result * a[i] * a[i+1] */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Finish any remaining elements */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		如上的例子即有效减小了循环开销，得到的延迟界限为 1.00。但是无论怎么增加展开次数，延迟界限都无法再突破。可以这样理解：循环展开实际上是使用 <code>vmulsd</code> 指令对 <em>xmm0</em> 寄存器每次进行一次读和一次写的操作。虽然我们增加循环展开次数，使得循环的次数以倍数折半，但是整个流程的关键路径实际上还是 n 个 <code>vmulsd</code> 操作——迭代次数减半了，但是每次迭代种还是有两个顺序的乘法操作（如 2 * 1 展开的情况）。</p>
<blockquote>
<p>编译器可以很容易地执行循环展开。只要优化级别设置地足够高，许多编译器都能例行公事地做到这一点。用优化等级 3 或者更高等级调用 GCC，他就会循环展开。</p>
</blockquote>
<h2 id="5-9-提高并行性"><a href="#5-9-提高并行性" class="headerlink" title="5.9 提高并行性"></a>5.9 提高并行性</h2><blockquote>
<p>之前所提到的种种可以发现程序的性能是受到运算单元的限制的。上面所说的诸如执行的加法和乘法的功能单元是完全流水线化的，每个时钟周期可以开始一个新的操作且有些操作可以被多个功能单元执行。硬件具有以高效率执行乘法和加法的潜力，但是代码不能利用这种能力。即使循环展开也不行，因为我们将累积值放在一个单独的变量 acc 中。在前面的计算完成之前，都不能计算 acc 的新值。虽然计算 acc 新值的功能单元能够每个时钟周期开始一个新的操作，但是它也只会每个<strong>合并操作的延迟</strong>个周期开始一条新的操作。所以我们需要打破这种顺序相关来获得比延迟界限更好的性能。</p>
</blockquote>
<p>​		对一个<strong>可结合和可变换</strong>的合并运算来说，可以通过将一组合并运算分割成两个或更多的部分，并且在最后合并来提高性能。最简单来说我们计算一串元素 a<del>0</del> ~ a<del>n</del> 的乘积 P<del>n</del>。我们可以写成 P<del>n</del> &#x3D; PE<del>n</del> * PO<del>n</del>，这里的 PE<del>n</del> 与 PO<del>n</del> 即分别为索引值为奇数和偶数的乘积，我们将其称为 2 * 2 展开。</p>
<h3 id="优化代码combine6："><a href="#优化代码combine6：" class="headerlink" title="优化代码combine6："></a>优化代码combine6：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 2 x 2 loop unrolling*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length<span class="number">-1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> *acc0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> *acc1 = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">        acc1 = acc1 OP data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Finish any remaining elements */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc0 OP acc1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		虽然这个操作循环内都包括两个 <code>vmulsd</code> 操作，但是这些指令的读写使用到了不同的寄存器，相互之间没有数据相关，然后再将这个操作复制了 <em>n&#x2F;2</em> 次，这样的我们观察整体操作就会发现有两条关键路径，所以延迟为 <em>L</em> 的操作实际上的 <em>CPE</em> 只有原来的一半，所以可以突破延迟界限获得更高的性能。在执行此等变换的时候，我们需要考虑两点，一个是是否要保留原始函数的功能，另一个是运算是否是可结合的，例如浮点乘法和加法就是不可结合的，可能会因为四舍五入或者溢出而产生不同的结果。大多数编译器不会尝试对浮点数代码进行这种变换，因为它们没有办法判断引入这种会改变程序行为的转换所带来的风险。</p>
<p>​		在 <em>combine5</em> 中合并语句为 <code>acc = (acc OP data[i]) OP data[i+1];</code> 在这里我们可以用另一种合并方式来极大的提高程序的性能：</p>
<h3 id="优化代码combine7："><a href="#优化代码combine7：" class="headerlink" title="优化代码combine7："></a>优化代码combine7：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 2 x 1a loop unrolling */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length<span class="number">-1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        acc = acc OP (data[i] OP data[i+<span class="number">1</span>]);   <span class="comment">/* 改变合并顺序 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Finish any remaining elements */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		我们可以这样来理解这改变合并顺序前后程序性能的差异：虽然我们统计操作次数都是两个 <code>vmulsd（两次读，两次写）</code> 但是只有其中一个 <code>vmulsd</code> 操作去参与形成循环寄存器间的数据相关链。然后将这个操作模板复制 <em>n&#x2F;2</em> 次。因此关键路径上只有 <em>n&#x2F;2</em> 个操作。每次迭代内的第一个乘法都不需要等待前一次迭代的累积值就可以执行。因此，最小可能的 CPE 减小了 2 倍。我们增加 <code>k x 1a</code> 的 k 值的结果同之前增加 <code> k x k 循环展开</code> 相似，都接近了由功能单元造成的吞吐量界限。</p>
<p>​		总的来说，重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元地流水线能力得到更好地性能。</p>
<h2 id="5-10-优化合并代码地结果小结"><a href="#5-10-优化合并代码地结果小结" class="headerlink" title="5.10 优化合并代码地结果小结"></a>5.10 优化合并代码地结果小结</h2><p>​		使用多项优化技术，我们获得的 CPE 已经接近于 0.50 和 1.00 的吞吐量界限，只受限于功能单元的容量。与原始代码相比提升了 10~20 倍，且使用普通的 C 代码和标准编译器就获得了所有这些改进。重写代码利用较新的 SIMD 指令得到了将近 4 倍或 8 倍的性能提升。比如单精度乘法，CPE 从初值 11.14 降到了 0.06, 整体性能提升超过 180 倍。 这个例子说明现代处理器具有相当的计算能力，但是我们可能需要按非常程式化的方式来编写程序以便将这些能力诱发出来。</p>
<h2 id="5-11-一些限制因素"><a href="#5-11-一些限制因素" class="headerlink" title="5.11 一些限制因素"></a>5.11 一些限制因素</h2><blockquote>
<p>​		我们已经看到在一个程序的数据流图表示中，关键路径指明了执行该程序所需时间的一个基本的下界。也就是说，如果程序中有某条数据相关链，这条链上的所有延迟之和等于 <em>T</em>，那么这个程序至少需要 <em>T</em> 个周期才能执行完。 </p>
<p>​		我们还看到功能单元的吞吐量界限也是程序执行时间的一个下界。也就是说，假设一 个程序一共需要 <em>N</em> 个某种运算的计算，而微处理器只有 C 个能执行这个操作的功能单元, 并且这些单元的发射时间为 7。那么，这个程序的执行至少需要 <em>N * I&#x2F;C</em> 个周期。 </p>
<p>​		接下来，我们会考虑其他一些制约程序在实际机器上性能的因素。</p>
</blockquote>
<p>​		循环并行性的好处受汇编代码描述计算的能力限制。如果我们的并行度 <em>p</em> 超过了可用的寄存器数量，那么编译器会诉诸溢出（spilling），将某些临时值存放到内存中，通常是在运行时堆栈上分配空间。一旦编译器必须要诉诸寄存器溢出，那么维护多个累积变量的优势就很可能消失。幸运的是，X86-64 有足够多的寄存器，大多数循环在出现寄存器溢出之前就将达到吞吐量限制。</p>
<p>​		当分支预测逻辑不能正确预测一个分支是否要跳转的时候，条件分支可能会招致很大的<strong>预测错误处罚</strong>。在一个使用<strong>投机执行（speculative execution）</strong>的处理器中，处理器会开始执行预测的分支目标处的指令。它会避免修改任何实际的寄存器或内存位置，直到确定了实际的结果。 如果预测正确，那么处理器就会”提交”投机执行的指令的结果，把它们存储到寄存器或内存。如果预测错误，处理器必须丢弃掉所有投机执行的结果，在正确的位置，重新开始取指令的过程。这样做会引起预测错误处罚，因为在产生有用的结果之前，必须重新填充指令流水线。</p>
<p>​		有以下通用原则去处理分支：</p>
<ol>
<li><strong>不要过分关心可预测地分支</strong></li>
</ol>
<p>​		错误的分支预测的影响可能非常大，但是这并不意味着所有的程序分支都会减缓程序的执行。实际上，现代处理器中的分支预测逻辑非常善于辨别不同的分支指令的有规律的模式和长期的趋势。而这些能被预测的分支求值都不会对形成程序执行中关键路径的指令的取指和处理产生太大的影响。</p>
<ol start="2">
<li><strong>书写适合用条件传送实现的代码</strong></li>
</ol>
<p>​		分支预测只对有规律的模式可行。程序中的许多测试是完全不可预测的，依赖于数据的任意特性，例如一个数是负数还是正数。对于这些测试，分支预测逻辑会处理得很糟糕。对于本质上无法预测的情况，如果编译器能够产生使用条件数据传送而不是使用条件控制转移的代码，可以极大地提高程序的性能。</p>
<h2 id="5-12-理解内存性能"><a href="#5-12-理解内存性能" class="headerlink" title="5.12 理解内存性能"></a>5.12 理解内存性能</h2><p>​		在之前我们都没有讨论到关于内存性能方面的问题，在我们的程序中，内存性能集中体现在加载操作上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write to dest, read from src */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dst, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src)+<span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">示例A:write_read(&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">事例B:write—read(&amp;a[<span class="number">0</span>],&amp;a[<span class="number">0</span>],<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>​		示例 A 从 src 读出的结果不受对 dest 的写的影响。而示例 B 指针引用 src 的每次加载都会得到指针引用 *dest 的前次执行存储的值。这种现象我们称之为<strong>写&#x2F;读相关（write&#x2F;read dependency）</strong>—— 一个内存读的结果依赖于一个最近的内存写。除了由于写和读寄存器造成的操作之间的数据相关，其中还有许多隐含的相关来影响程序性能。比如地址计算必须在数值写入之前完成等。</p>
<p>​		内存操作的实现包括许多细微之处。对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。另一方面，对于内存 操作，只有到计算出加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响 其他的哪些。高效地处理内存操作对许多程序的性能来说至关重要。内存子系统使用了很多优化，例如当操作可以独立地进行时，就利用这种潜在的并行性。</p>
<h2 id="5-13-应用：性能提高技术"><a href="#5-13-应用：性能提高技术" class="headerlink" title="5.13 应用：性能提高技术"></a>5.13 应用：性能提高技术</h2><p>优化程序性能的基本策略：</p>
<p>1）<strong>高级设计</strong>。为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。</p>
<p>2）<strong>基本编码原则</strong>。避免限制优化的因素，这样编译器就能产生高效的代码。</p>
<ul>
<li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获得更大的效率。</li>
<li>消除不必要的内存引用。引人临时变量来保存中间结果。只有在最后的值计算出 时，才将结果存放到数组或全局变量中。</li>
</ul>
<p>3）<strong>低级优化</strong>。结构化代码以利用硬件功能。</p>
<ul>
<li>展开循环，降低开销，并且使得进一步的优化成为可能。</li>
<li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。</li>
<li>用功能性的风格重写条件操作，使得编译采用条件数据传送。</li>
</ul>
<h2 id="5-14-确认和消除性能瓶颈"><a href="#5-14-确认和消除性能瓶颈" class="headerlink" title="5.14 确认和消除性能瓶颈"></a>5.14 确认和消除性能瓶颈</h2><p>略</p>
<h2 id="5-15-小结"><a href="#5-15-小结" class="headerlink" title="5.15 小结"></a>5.15 小结</h2><p>​		虽然关于代码优化的大多数论述都描述了编译器是如何能生成髙效代码的，但是应用程序员有很多方法来协助编译器完成这项任务。没有任何编译器能用一个好的算法或数据结构代替低效率的算法或数据结构，因此程序设计的这些方面仍然应该是程序员主要关心的。我们还看到妨碍优化的因素，例如内存别名 使用和过程调用，严重限制了编译器执行大量优化的能力。同样，程序员必须对消除这些妨碍优化的因素负主要的责任。这些应该被看作好的编程习惯的一部分，因为它们可以用来消除不必要的工作。</p>
<p>​		基本级别之外调整性能需要一些对处理器微体系结构的理解，描述处理器用来实现它的指令集体系 结构的底层机制。对于乱序处理器的情况，只需要知道一些关于操作、容量、延迟和功能单元发射时间的信息，就能够基本地预测程序的性能了。</p>
<p>​		我们研究了一系列技术，包括循环展开、创建多个累积变量和重新结合，它们可以利用现代处理器 提供的指令级并行。随着对优化的深人，研究产生的汇编代码以及试着理解机器如何执行计算变得重要 起来。确认由程序中的数据相关决定的关键路径，尤其是循环的不同迭代之间的数据相关，会收获良多。 我们还可以根据必须要计算的操作数量以及执行这些操作的功能单元的数量和发射时间，计算一个计算的吞吐量界限。</p>
<p>​		包含条件分支或与内存系统复杂交互的程序，比我们最开始考虑的简单循环程序，更难以分析和优 化。基本策略是使分支更容易预测，或者使它们很容易用条件数据传送来实现。我们还必须注意存储和 加载操作。将数值保存在局部变量中，使得它们可以存放在寄存器中，这会很有帮助。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://kamasammohana.github.io/2022/11/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/11/13/angr%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            angr 学习笔记
          
        </div>
      </a>
    
    
      <a href="/2022/10/28/CMake%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">CMake 学习笔记</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> Syclover.Kama
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Kama"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://bcyng-w.github.io">Friends Chain B</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://sycskye.xyz">Friends Chain C</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://lzhnb.site">Friends Chain H</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=391426134&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>